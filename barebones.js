// Generated by CoffeeScript 1.6.3
var Collection, Model, array, attributeMethods, method, methods, push, slice, splice, unshift, _i, _j, _len, _len1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

array = [];

push = array.push;

slice = array.slice;

splice = array.splice;

unshift = array.unshift;

Model = (function(_super) {
  __extends(Model, _super);

  function Model(model) {
    var prop, val;
    for (prop in model) {
      val = model[prop];
      this.prop = val;
    }
  }

  return Model;

})(Object);

Collection = (function(_super) {
  __extends(Collection, _super);

  function Collection(models, options) {
    this._prepareModel = __bind(this._prepareModel, this);
    this.unshift = __bind(this.unshift, this);
    this.push = __bind(this.push, this);
    var model, _i, _len;
    options || (options = {});
    if (options.model) {
      this.model = options.model;
    }
    for (_i = 0, _len = models.length; _i < _len; _i++) {
      model = models[_i];
      this.models.push(model);
    }
    this.initialize();
  }

  Collection.prototype.model = Model;

  Collection.prototype.models = [];

  Collection.prototype.push = function(model) {
    model = this._prepareModel(model);
    return this.models.push(model);
  };

  Collection.prototype.unshift = function(model) {
    model = this._prepareModel(model);
    return this.models.unshift(model);
  };

  Collection.prototype._prepareModel = function(model) {
    if (!(model instanceof this.model)) {
      model = new this.model(model);
    }
    return model;
  };

  Collection.prototype.initialize = function() {};

  return Collection;

})(Object);

methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest', 'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain'];

methods.concat(['pluck', 'findWhere']);

for (_i = 0, _len = methods.length; _i < _len; _i++) {
  method = methods[_i];
  Collection.prototype[method] = function() {
    var args;
    args = slice.call(arguments);
    args.unshift(this.models);
    return _[method].apply(_, args);
  };
}

attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

for (_j = 0, _len1 = attributeMethods.length; _j < _len1; _j++) {
  method = attributeMethods[_j];
  Collection.prototype[method] = function(value, context) {
    var iterator;
    iterator = _.isFunction(value) ? value : function(model) {
      return model[value];
    };
    return _[method](this.models, iterator, context);
  };
}

window.Barebones = {
  Model: Model,
  Collection: Collection
};
