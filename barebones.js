// Generated by CoffeeScript 1.6.3
var factory,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

(function(root, factory) {
  var _;
  if (typeof define === "function" && define.amd) {
    define(["underscore", "exports"], function(_, exports) {
      root.Barebones = factory(root, exports, _);
    });
  } else if (typeof exports !== "undefined") {
    _ = require("underscore") || require("lodash");
    factory(root, exports, _);
  } else {
    root.Barebones = factory(root, {}, root._);
  }
})(this, factory);

factory = function(root, Barebones, _) {
  var Collection, Model, array, attributeMethods, collectionMethods, lib, method, methodName, nativeMethods, push, returnsCollectionMethods, slice, splice, unshift, _i, _j, _k, _l, _len, _len1, _len2, _len3;
  lib = _.noop ? "lodash" : "underscore";
  array = [];
  push = array.push;
  slice = array.slice;
  splice = array.splice;
  unshift = array.unshift;
  Model = (function(_super) {
    __extends(Model, _super);

    function Model(model) {
      var prop, val;
      for (prop in model) {
        val = model[prop];
        this.prop = val;
      }
    }

    return Model;

  })(Object);
  Collection = (function(_super) {
    __extends(Collection, _super);

    function Collection(models, options) {
      this._prepareModel = __bind(this._prepareModel, this);
      this.concat = __bind(this.concat, this);
      this.unshift = __bind(this.unshift, this);
      this.push = __bind(this.push, this);
      this.length = __bind(this.length, this);
      var model, _i, _len;
      options || (options = {});
      if (options.model) {
        this.model = options.model;
      }
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        this.push(model);
      }
      this.initialize();
    }

    Collection.prototype.model = Model;

    Collection.prototype.models = [];

    Collection.prototype.length = function() {
      return this.models.length;
    };

    Collection.prototype.push = function(model) {
      return this.models.push(this._prepareModel(model));
    };

    Collection.prototype.unshift = function(model) {
      return this.models.unshift(this._prepareModel(model));
    };

    Collection.prototype.concat = function(arrayOfModels) {
      var model, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = aarayOfModels.length; _i < _len; _i++) {
        model = aarayOfModels[_i];
        _results.push(this.push(model));
      }
      return _results;
    };

    Collection.prototype._prepareModel = function(model) {
      if (!(model instanceof this.model)) {
        model = new this.model(model);
      }
      return model;
    };

    Collection.prototype.initialize = function() {};

    return Collection;

  })(Object);
  collectionMethods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest', 'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain'];
  collectionMethods.concat(['pluck', 'where', 'findWhere']);
  if (lib === "lodash") {
    collectionMethods.concat(['at', 'eachRight', 'forEachRight', 'findLast']);
  }
  for (_i = 0, _len = collectionMethods.length; _i < _len; _i++) {
    method = collectionMethods[_i];
    Collection.prototype[method] = function() {
      var args;
      args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  }
  attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];
  for (_j = 0, _len1 = attributeMethods.length; _j < _len1; _j++) {
    method = attributeMethods[_j];
    Collection.prototype[method] = function(value, context) {
      var iterator;
      iterator = _.isFunction(value) ? value : function(model) {
        return model[value];
      };
      return _[method](this.models, iterator, context);
    };
  }
  nativeMethods = ['slice', 'splice', 'shift', 'pop', 'join', 'reverse', 'sort'];
  for (_k = 0, _len2 = nativeMethods.length; _k < _len2; _k++) {
    method = nativeMethods[_k];
    Collection.prototype[method] = function() {
      var args;
      args = slice.call(arguments);
      args.unshift(this.models);
      return Array.prototype[method].apply(null, arguments);
    };
  }
  returnsCollectionMethods = ['filter', 'where', 'reject'];
  for (_l = 0, _len3 = returnsCollectionMethods.length; _l < _len3; _l++) {
    method = returnsCollectionMethods[_l];
    methodName = "col" + method.charAt(0).toUpperCase() + method.slice(1);
    Collection.prototype[methodName] = function() {
      var args;
      args = slice.call(arguments);
      args.unshift(this.models);
      return new this.constructor(_[method].apply(_, args));
    };
  }
  return {
    Model: Model,
    Collection: Collection
  };
};
