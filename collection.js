// Generated by CoffeeScript 1.7.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function(root, factory) {
  var _;
  if (typeof define === "function" && define.amd) {
    return define(["lodash", "exports"], function(_, exports) {
      root.Collection = factory(root, exports, _);
    });
  } else if (typeof exports !== "undefined") {
    _ = require("lodash");
    return factory(root, exports, _);
  } else {
    return root.Collection = factory(root, {}, root._);
  }
})(this, function(root, Collection, _) {
  var addArg, arrayMethods, lodashMethods, method, notReturnsCollectionMethods, previousCollection, returnsCollectionMethods, slice, _fn, _fn1, _i, _j, _len, _len1;
  previousCollection = root.Collection;
  slice = Function.prototype.call.bind(Array.prototype.slice);
  addArg = function(arg, args) {
    args = slice(args);
    args.unshift(arg);
    return args;
  };
  Collection = (function(_super) {
    __extends(Collection, _super);

    function Collection(models, options) {
      var model, _i, _len;
      options || (options = {});
      if (models) {
        for (_i = 0, _len = models.length; _i < _len; _i++) {
          model = models[_i];
          if (options.init) {
            model = (function(m) {
              return options.init(m);
            })(model);
          }
          this.push(model);
        }
      }
    }

    return Collection;

  })(Array);
  arrayMethods = ["slice", "splice", "concat"];
  _fn = function(method) {
    return Collection.prototype.method = function() {
      return new Collection(method.apply(this, arguments));
    };
  };
  for (_i = 0, _len = arrayMethods.length; _i < _len; _i++) {
    method = arrayMethods[_i];
    _fn(method);
  }
  returnsCollectionMethods = ['forEach', 'each', 'eachRight', 'forEachRight', 'map', 'collect', 'filter', 'select', 'where', 'pluck', 'reject', 'invoke', 'initial', 'rest', 'tail', 'drop', 'compact', 'flatten', 'without', 'shuffle', 'remove', 'transform', 'unique', 'uniq', 'union', 'intersection', 'difference'];
  notReturnsCollectionMethods = ['reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'findWhere', 'every', 'all', 'some', 'any', 'contains', 'max', 'min', 'include', 'size', 'first', 'last', 'indexOf', 'lastIndexOf', 'isEmpty', 'toArray', 'at', 'findLast', 'indexBy', 'sortBy', 'countBy'];
  lodashMethods = returnsCollectionMethods.concat(notReturnsCollectionMethods);
  _fn1 = function(method) {
    var retCol;
    if (_[method]) {
      retCol = __indexOf.call(returnsCollectionMethods, method) >= 0;
      return Collection.prototype[method] = function() {
        var result;
        result = _[method].apply(_, addArg(this, arguments));
        if (retCol) {
          return new Collection(result);
        } else {
          return result;
        }
      };
    }
  };
  for (_j = 0, _len1 = lodashMethods.length; _j < _len1; _j++) {
    method = lodashMethods[_j];
    _fn1(method);
  }
  Collection.noConflict = function() {
    root.Collection = previousCollection;
    return this;
  };
  return Collection;
});
